/**
 * ⚠️ DEPRECATED: This file is now a compatibility layer
 * 
 * The API services have been restructured into a feature-based architecture.
 * This file re-exports from the new modular structure for backward compatibility.
 * 
 * New import paths:
 * - TourService: ../src/features/tours/services/tour.service
 * - BookingService: ../src/features/bookings/services/booking.service
 * - WaitlistService: ../src/features/bookings/services/booking.service
 * - CustomerService: ../src/features/customers/services/customer.service
 * - PromoCodeService: ../src/features/marketing/services/promo.service
 * - AuthService: ../src/shared/services/auth.service
 * 
 * Or use the convenient central export:
 * import { TourService, BookingService } from '../src/shared/services';
 */

// Re-export everything from the new modular structure
export {
  TourService,
  BookingService,
  WaitlistService,
  CustomerService,
  PromoCodeService,
  AuthService
} from '../src/shared/services';

// Mock Data
const MOCK_TOURS: Tour[] = [
  {
    id: '1',
    title: 'Bestig Kilimanjaro',
    shortDescription: '8 DAGAR PÅ BERGET. Vandra genom fyra klimatzoner till toppen av Afrika.',
    description: 'Vandra genom fyra klimatzoner på vår unika rutt till toppen av Afrika, Uhuru Peak 5895 m höjd. En expedition utöver det vanliga med erfarna guider.',
    price: 45900,
    depositPrice: 5000,
    currency: 'SEK',
    durationDays: 10,
    difficulty: 'Extreme',
    imageUrl: 'https://images.unsplash.com/photo-1650635462886-069f20e98033?q=80&w=1000&auto=format&fit=crop', // Kilimanjaro
    location: 'Tanzania',
    nextDate: '2026-01-24',
    availableSpots: 4
  },
  {
    id: '2',
    title: 'Langtang & Tamang Heritage',
    shortDescription: '14 DAGAR. Äkta kulturmöten och storslagna Himalayavyer.',
    description: 'Följ med Aventra på en unik vandringsresa genom Tamang Heritage och Langtangdalen. Äkta kulturmöten, storslagna Himalayavyer och svensk guide.',
    price: 40900,
    depositPrice: 4000,
    currency: 'SEK',
    durationDays: 14,
    difficulty: 'Hard',
    imageUrl: 'https://images.unsplash.com/photo-1544735716-392fe2489ffa?q=80&w=1000&auto=format&fit=crop', // Himalayas
    location: 'Nepal',
    nextDate: '2026-02-23',
    availableSpots: 0  // Fully booked for testing
  },
  {
    id: '3',
    title: 'Patagonien',
    shortDescription: '12 DAGAR. Vandra W-trek i Torres del Paine.',
    description: 'Vandra W-trek i Torres del Paine och upplev Cerro Castillo i Aysén – en resa med svensk guide och storslagna naturupplevelser.',
    price: 64900,
    depositPrice: 6000,
    currency: 'SEK',
    durationDays: 12,
    difficulty: 'Hard',
    imageUrl: 'https://images.unsplash.com/photo-1533105079780-92b9be482077?q=80&w=1000&auto=format&fit=crop', // Patagonia
    location: 'Chile',
    nextDate: '2026-02-25',
    availableSpots: 12
  }
];

// Helper to create a dummy payer
const mockPayer: PayerDetails = {
    firstName: 'Alice', lastName: 'Anderson', email: 'alice@example.com', phone: '0701234567', 
    address: 'Sveavägen 1', zipCode: '111 57', city: 'Stockholm', country: 'Sweden'
};

const MOCK_BOOKINGS: Booking[] = [
  {
    id: 'BK-1001',
    tourId: '1',
    tourTitle: 'Bestig Kilimanjaro',
    customerId: 'cust_1',
    customerName: 'Alice Anderson',
    payer: mockPayer,
    bookingDate: '2024-01-15',
    tripDate: '2026-01-24',
    participants: 2,
    travelers: [
      { firstName: 'Alice', lastName: 'Anderson', email: 'alice@example.com', phone: '0701234567', address: 'Sveavägen 1', zipCode: '111 57', city: 'Stockholm', country: 'Sweden', ssn: '19900101-1234', isPayer: true, roomPreference: 'Double Bed' },
      { firstName: 'Bob', lastName: 'Builder', email: 'bob@example.com', phone: '0709876543', address: 'Sveavägen 1', zipCode: '111 57', city: 'Stockholm', country: 'Sweden', ssn: '19900102-5678', isPayer: false, roomPreference: 'Double Bed' }
    ],
    totalAmount: 82620, // 91800 - 9180 (10% discount with SUMMER2026)
    paidAmount: 82620,
    status: BookingStatus.CONFIRMED,
    paymentStatus: PaymentStatus.PAID,
    transactionId: 'pi_3M9e2jLkdiw812',
    promoCode: 'SUMMER2026',
    discountAmount: 9180
  },
  {
    id: 'BK-1002',
    tourId: '2',
    tourTitle: 'Langtang & Tamang Heritage',
    customerId: 'cust_2',
    customerName: 'Bjorn Borg',
    payer: { ...mockPayer, firstName: 'Bjorn', lastName: 'Borg', email: 'bjorn@tennis.se' },
    bookingDate: '2024-02-10',
    tripDate: '2026-02-23',
    participants: 1,
    travelers: [
       { firstName: 'Bjorn', lastName: 'Borg', email: 'bjorn@tennis.se', phone: '0705555555', address: 'Center Court 1', zipCode: '269 00', city: 'Båstad', country: 'Sweden', ssn: '19800606-9999', isPayer: true, roomPreference: 'Single Room', travelCompanion: 'None' }
    ],
    totalAmount: 40900,
    paidAmount: 4000,
    status: BookingStatus.PENDING,
    paymentStatus: PaymentStatus.PARTIAL,
    transactionId: 'pi_3L8x1kMjaus901'
  },
  {
    id: 'BK-1003',
    tourId: '3',
    tourTitle: 'Patagonien',
    customerId: 'cust_3',
    customerName: 'Charlie Chaplin',
    payer: { ...mockPayer, firstName: 'Charlie', lastName: 'Chaplin', email: 'charlie@movies.com' },
    bookingDate: '2024-03-05',
    tripDate: '2026-02-25',
    participants: 4,
    travelers: [], // Simplified for mock
    totalAmount: 259600, // 64900 * 4
    paidAmount: 0,
    status: BookingStatus.CANCELLED,
    paymentStatus: PaymentStatus.UNPAID,
    transactionId: undefined
  },
  {
    id: 'BK-1004',
    tourId: '1',
    tourTitle: 'Bestig Kilimanjaro',
    customerId: 'cust_4',
    customerName: 'David Davidson',
    payer: { ...mockPayer, firstName: 'David', lastName: 'Davidson', email: 'david@example.com' },
    bookingDate: '2024-03-12',
    tripDate: '2026-01-24',
    participants: 1,
    travelers: [],
    totalAmount: 45900,
    paidAmount: 45900,
    status: BookingStatus.COMPLETED,
    paymentStatus: PaymentStatus.PAID,
    transactionId: 'pi_9K2j1kLqa771'
  },
  {
    id: 'BK-1005',
    tourId: '2',
    tourTitle: 'Langtang & Tamang Heritage',
    customerId: 'cust_5',
    customerName: 'Eva Evans',
    payer: { ...mockPayer, firstName: 'Eva', lastName: 'Evans', email: 'eva@example.com' },
    bookingDate: '2024-03-20',
    tripDate: '2026-02-23',
    participants: 2,
    travelers: [],
    totalAmount: 81800, // 40900 * 2
    paidAmount: 8000,
    status: BookingStatus.CONFIRMED,
    paymentStatus: PaymentStatus.PARTIAL,
    transactionId: 'pi_8J1h2gFda332'
  },
  {
    id: 'BK-1006',
    tourId: '3',
    tourTitle: 'Patagonien',
    customerId: 'cust_6',
    customerName: 'Frank Franklin',
    payer: { ...mockPayer, firstName: 'Frank', lastName: 'Franklin', email: 'frank@example.com' },
    bookingDate: '2024-04-01',
    tripDate: '2026-02-25',
    participants: 2,
    travelers: [],
    totalAmount: 129800, // 64900 * 2
    paidAmount: 129800,
    status: BookingStatus.PENDING,
    paymentStatus: PaymentStatus.PAID,
    transactionId: 'pi_7H6g5fDsa221'
  }
];

export const TourService = {
  getAll: async (): Promise<Tour[]> => {
    await delay(500);
    return MOCK_TOURS;
  },
  getById: async (id: string): Promise<Tour | undefined> => {
    await delay(300);
    return MOCK_TOURS.find(t => t.id === id);
  }
};

export const BookingService = {
  create: async (bookingData: Partial<Booking>): Promise<Booking> => {
    await delay(1000);
    
    const newBooking: Booking = {
      id: `BK-${Math.floor(Math.random() * 10000)}`,
      tourId: bookingData.tourId || '',
      tourTitle: bookingData.tourTitle || '',
      customerId: 'cust_current',
      customerName: bookingData.payer ? `${bookingData.payer.firstName} ${bookingData.payer.lastName}` : 'Guest',
      payer: bookingData.payer || mockPayer,
      bookingDate: new Date().toISOString().split('T')[0],
      tripDate: bookingData.tripDate || '',
      participants: bookingData.participants || 1,
      travelers: bookingData.travelers || [],
      totalAmount: bookingData.totalAmount || 0,
      paidAmount: bookingData.paidAmount || 0,
      status: BookingStatus.CONFIRMED,
      paymentStatus: PaymentStatus.PARTIAL,
      transactionId: `pi_mock_${Math.random().toString(36).substring(7)}`,
      tourImageUrl: bookingData.tourImageUrl,
      ...bookingData
    } as Booking;
    
    MOCK_BOOKINGS.push(newBooking);
    console.log('API Call: Creating booking', newBooking);
    console.log('Tour Image URL:', newBooking.tourImageUrl);
    return newBooking;
  },
  
  update: async (id: string, updates: Partial<Booking>): Promise<Booking> => {
    await delay(800);
    const index = MOCK_BOOKINGS.findIndex(b => b.id === id);
    if (index === -1) throw new Error('Booking not found');
    
    // Update the booking in mock db
    MOCK_BOOKINGS[index] = { ...MOCK_BOOKINGS[index], ...updates };
    
    // If payer name changed, update top level customer name too
    if (updates.payer) {
       MOCK_BOOKINGS[index].customerName = `${updates.payer.firstName} ${updates.payer.lastName}`;
    }

    return MOCK_BOOKINGS[index];
  },

  getAll: async (): Promise<Booking[]> => {
    await delay(600);
    return MOCK_BOOKINGS;
  },

  getStats: async (): Promise<DashboardStats> => {
    await delay(400);
    return {
      totalRevenue: 2540000, // SEK
      activeBookings: 45,
      pendingInquiries: 12,
      occupancyRate: 85
    };
  }
};

export const WaitlistService = {
  create: async (waitlistData: Partial<Waitlist>): Promise<Waitlist> => {
    await delay(500);
    
    const newWaitlist: Waitlist = {
      id: `WL-${Math.floor(Math.random() * 10000)}`,
      tourId: waitlistData.tourId || '',
      tourTitle: waitlistData.tourTitle || '',
      firstName: waitlistData.firstName || '',
      lastName: waitlistData.lastName || '',
      email: waitlistData.email || '',
      phone: waitlistData.phone || '',
      participants: waitlistData.participants || 1,
      preferredDate: waitlistData.preferredDate,
      message: waitlistData.message,
      submittedDate: new Date().toISOString().split('T')[0],
      status: 'PENDING'
    };
    
    // Save to localStorage
    try {
      const existingWaitlist = localStorage.getItem('tourWaitlist');
      const waitlist = existingWaitlist ? JSON.parse(existingWaitlist) : [];
      waitlist.push(newWaitlist);
      localStorage.setItem('tourWaitlist', JSON.stringify(waitlist));
    } catch (storageError) {
      console.error('Failed to save waitlist to localStorage', storageError);
    }
    
    console.log('Waitlist created:', newWaitlist);
    return newWaitlist;
  },
  
  getAll: async (): Promise<Waitlist[]> => {
    await delay(300);
    try {
      const storedWaitlist = localStorage.getItem('tourWaitlist');
      return storedWaitlist ? JSON.parse(storedWaitlist) : [];
    } catch (error) {
      console.error('Failed to load waitlist from localStorage', error);
      return [];
    }
  },
  
  update: async (id: string, updates: Partial<Waitlist>): Promise<Waitlist> => {
    await delay(500);
    try {
      const storedWaitlist = localStorage.getItem('tourWaitlist');
      const waitlist = storedWaitlist ? JSON.parse(storedWaitlist) : [];
      const index = waitlist.findIndex((w: Waitlist) => w.id === id);
      
      if (index === -1) throw new Error('Waitlist entry not found');
      
      waitlist[index] = { ...waitlist[index], ...updates };
      localStorage.setItem('tourWaitlist', JSON.stringify(waitlist));
      
      return waitlist[index];
    } catch (error) {
      console.error('Failed to update waitlist entry', error);
      throw error;
    }
  }
};

export const CustomerService = {
  getAll: async (): Promise<Customer[]> => {
    await delay(400);
    
    // Extract unique customers from bookings
    const customerMap = new Map<string, Customer>();
    
    MOCK_BOOKINGS.forEach(booking => {
      const customerId = booking.customerId;
      const payer = booking.payer;
      
      if (!customerMap.has(customerId)) {
        customerMap.set(customerId, {
          id: customerId,
          firstName: payer.firstName,
          lastName: payer.lastName,
          email: payer.email,
          phone: payer.phone,
          address: payer.address,
          zipCode: payer.zipCode,
          city: payer.city,
          country: payer.country,
          totalBookings: 0,
          totalSpent: 0,
          createdDate: booking.bookingDate,
          lastBookingDate: booking.bookingDate,
          notes: ''
        });
      }
      
      const customer = customerMap.get(customerId)!;
      customer.totalBookings++;
      customer.totalSpent += booking.paidAmount;
      
      // Update last booking date if this booking is more recent
      if (booking.bookingDate > (customer.lastBookingDate || '')) {
        customer.lastBookingDate = booking.bookingDate;
      }
      
      // Update created date if this booking is older
      if (booking.bookingDate < customer.createdDate) {
        customer.createdDate = booking.bookingDate;
      }
    });
    
    return Array.from(customerMap.values());
  },
  
  getById: async (id: string): Promise<Customer | undefined> => {
    await delay(300);
    const customers = await CustomerService.getAll();
    return customers.find(c => c.id === id);
  },
  
  getCustomerBookings: async (customerId: string): Promise<Booking[]> => {
    await delay(400);
    return MOCK_BOOKINGS.filter(b => b.customerId === customerId);
  },
  
  update: async (id: string, updates: Partial<Customer>): Promise<Customer> => {
    await delay(500);
    
    // Update all bookings with this customer's payer info
    MOCK_BOOKINGS.forEach(booking => {
      if (booking.customerId === id && updates) {
        if (updates.firstName || updates.lastName || updates.email || updates.phone || 
            updates.address || updates.zipCode || updates.city || updates.country) {
          booking.payer = {
            ...booking.payer,
            ...(updates.firstName && { firstName: updates.firstName }),
            ...(updates.lastName && { lastName: updates.lastName }),
            ...(updates.email && { email: updates.email }),
            ...(updates.phone && { phone: updates.phone }),
            ...(updates.address && { address: updates.address }),
            ...(updates.zipCode && { zipCode: updates.zipCode }),
            ...(updates.city && { city: updates.city }),
            ...(updates.country && { country: updates.country })
          };
          
          booking.customerName = `${booking.payer.firstName} ${booking.payer.lastName}`;
        }
      }
    });
    
    const customer = await CustomerService.getById(id);
    if (!customer) throw new Error('Customer not found');
    
    return { ...customer, ...updates };
  }
};

export const AuthService = {
  login: async (email: string, role: UserRole): Promise<User> => {
    await delay(500);
    return {
      id: 'u_123',
      name: email.split('@')[0],
      email: email,
      role: role
    };
  }
};

// Import PromoCode types
import { PromoCode, PromoCodeType, PromoCodeStatus, PromoCodeValidation } from '../types';

// Mock Promo Codes Data
const MOCK_PROMO_CODES: PromoCode[] = [
  {
    id: 'PC-001',
    code: 'SUMMER2026',
    description: 'Summer promotion - 10% off all tours',
    type: PromoCodeType.PERCENTAGE,
    value: 10,
    minBookingAmount: 10000,
    maxDiscount: 5000,
    usageLimit: 100,
    usageCount: 23,
    validFrom: '2026-01-01',
    validUntil: '2026-08-31',
    status: PromoCodeStatus.ACTIVE,
    applicableTours: [], // Empty means all tours
    createdBy: 'admin',
    createdDate: '2025-11-01',
    lastModified: '2025-11-15'
  },
  {
    id: 'PC-002',
    code: 'KILIMANJARO500',
    description: 'Special discount for Kilimanjaro tours',
    type: PromoCodeType.FIXED_AMOUNT,
    value: 500,
    minBookingAmount: 40000,
    usageLimit: 50,
    usageCount: 12,
    validFrom: '2025-12-01',
    validUntil: '2026-03-31',
    status: PromoCodeStatus.ACTIVE,
    applicableTours: ['1'], // Only for Kilimanjaro
    createdBy: 'admin',
    createdDate: '2025-11-20',
  },
  {
    id: 'PC-003',
    code: 'EARLYBIRD20',
    description: 'Early bird 20% discount',
    type: PromoCodeType.PERCENTAGE,
    value: 20,
    minBookingAmount: 20000,
    maxDiscount: 10000,
    usageLimit: 30,
    usageCount: 30,
    validFrom: '2025-10-01',
    validUntil: '2025-12-31',
    status: PromoCodeStatus.EXPIRED,
    applicableTours: [],
    createdBy: 'admin',
    createdDate: '2025-09-15',
  },
  {
    id: 'PC-004',
    code: 'WINTER25',
    description: 'Winter special - 25% off',
    type: PromoCodeType.PERCENTAGE,
    value: 25,
    minBookingAmount: 30000,
    maxDiscount: 15000,
    usageLimit: null, // Unlimited
    usageCount: 0,
    validFrom: '2026-01-15',
    validUntil: '2026-03-15',
    status: PromoCodeStatus.INACTIVE,
    applicableTours: ['2', '3'], // Nepal and Patagonia
    createdBy: 'admin',
    createdDate: '2025-11-28',
  }
];

export const PromoCodeService = {
  /**
   * Get all promo codes (for admin)
   */
  getAll: async (): Promise<PromoCode[]> => {
    await delay(400);
    try {
      const stored = localStorage.getItem('promoCodes');
      if (stored) {
        return JSON.parse(stored);
      }
      // Initialize with mock data
      localStorage.setItem('promoCodes', JSON.stringify(MOCK_PROMO_CODES));
      return MOCK_PROMO_CODES;
    } catch (error) {
      console.error('Failed to load promo codes', error);
      return MOCK_PROMO_CODES;
    }
  },

  /**
   * Get a single promo code by ID
   */
  getById: async (id: string): Promise<PromoCode | undefined> => {
    await delay(300);
    const promoCodes = await PromoCodeService.getAll();
    return promoCodes.find(pc => pc.id === id);
  },

  /**
   * Validate and apply promo code to booking
   */
  validatePromoCode: async (
    code: string,
    tourId: string,
    bookingAmount: number
  ): Promise<PromoCodeValidation> => {
    await delay(600);
    
    const promoCodes = await PromoCodeService.getAll();
    const promoCode = promoCodes.find(pc => pc.code.toUpperCase() === code.toUpperCase());

    // Validation checks
    if (!promoCode) {
      return {
        isValid: false,
        message: 'Invalid promo code'
      };
    }

    // Check status
    if (promoCode.status !== PromoCodeStatus.ACTIVE) {
      return {
        isValid: false,
        message: 'This promo code is not active'
      };
    }

    // Check date validity
    const now = new Date();
    const validFrom = new Date(promoCode.validFrom);
    const validUntil = new Date(promoCode.validUntil);

    if (now < validFrom) {
      return {
        isValid: false,
        message: `This promo code is not valid until ${promoCode.validFrom}`
      };
    }

    if (now > validUntil) {
      return {
        isValid: false,
        message: 'This promo code has expired'
      };
    }

    // Check usage limit
    if (promoCode.usageLimit !== null && promoCode.usageLimit !== undefined) {
      if (promoCode.usageCount >= promoCode.usageLimit) {
        return {
          isValid: false,
          message: 'This promo code has reached its usage limit'
        };
      }
    }

    // Check minimum booking amount
    if (promoCode.minBookingAmount && bookingAmount < promoCode.minBookingAmount) {
      return {
        isValid: false,
        message: `Minimum booking amount of ${promoCode.minBookingAmount} SEK required`
      };
    }

    // Check applicable tours
    if (promoCode.applicableTours && promoCode.applicableTours.length > 0) {
      if (!promoCode.applicableTours.includes(tourId)) {
        return {
          isValid: false,
          message: 'This promo code is not applicable to this tour'
        };
      }
    }

    // Calculate discount
    let discountAmount = 0;
    if (promoCode.type === PromoCodeType.PERCENTAGE) {
      discountAmount = (bookingAmount * promoCode.value) / 100;
      
      // Apply max discount cap if specified
      if (promoCode.maxDiscount && discountAmount > promoCode.maxDiscount) {
        discountAmount = promoCode.maxDiscount;
      }
    } else if (promoCode.type === PromoCodeType.FIXED_AMOUNT) {
      discountAmount = promoCode.value;
    }

    // Ensure discount doesn't exceed booking amount
    discountAmount = Math.min(discountAmount, bookingAmount);

    const finalAmount = bookingAmount - discountAmount;

    return {
      isValid: true,
      message: 'Promo code applied successfully!',
      discountAmount: Math.round(discountAmount),
      finalAmount: Math.round(finalAmount)
    };
  },

  /**
   * Create a new promo code
   */
  create: async (promoCodeData: Omit<PromoCode, 'id' | 'usageCount' | 'createdDate'>): Promise<PromoCode> => {
    await delay(500);
    
    const promoCodes = await PromoCodeService.getAll();
    
    // Check if code already exists
    const existingCode = promoCodes.find(
      pc => pc.code.toUpperCase() === promoCodeData.code.toUpperCase()
    );
    
    if (existingCode) {
      throw new Error('A promo code with this code already exists');
    }

    const newPromoCode: PromoCode = {
      id: `PC-${Date.now()}`,
      ...promoCodeData,
      usageCount: 0,
      createdDate: new Date().toISOString().split('T')[0]
    };

    promoCodes.push(newPromoCode);
    localStorage.setItem('promoCodes', JSON.stringify(promoCodes));
    
    return newPromoCode;
  },

  /**
   * Update an existing promo code
   */
  update: async (id: string, updates: Partial<PromoCode>): Promise<PromoCode> => {
    await delay(500);
    
    const promoCodes = await PromoCodeService.getAll();
    const index = promoCodes.findIndex(pc => pc.id === id);
    
    if (index === -1) {
      throw new Error('Promo code not found');
    }

    // If code is being updated, check for duplicates
    if (updates.code && updates.code !== promoCodes[index].code) {
      const duplicate = promoCodes.find(
        pc => pc.id !== id && pc.code.toUpperCase() === updates.code!.toUpperCase()
      );
      if (duplicate) {
        throw new Error('A promo code with this code already exists');
      }
    }

    promoCodes[index] = {
      ...promoCodes[index],
      ...updates,
      lastModified: new Date().toISOString().split('T')[0]
    };

    localStorage.setItem('promoCodes', JSON.stringify(promoCodes));
    
    return promoCodes[index];
  },

  /**
   * Delete a promo code
   */
  delete: async (id: string): Promise<void> => {
    await delay(400);
    
    const promoCodes = await PromoCodeService.getAll();
    const filtered = promoCodes.filter(pc => pc.id !== id);
    
    if (filtered.length === promoCodes.length) {
      throw new Error('Promo code not found');
    }

    localStorage.setItem('promoCodes', JSON.stringify(filtered));
  },

  /**
   * Increment usage count when promo code is used
   */
  incrementUsage: async (code: string): Promise<void> => {
    await delay(300);
    
    const promoCodes = await PromoCodeService.getAll();
    const promoCode = promoCodes.find(pc => pc.code.toUpperCase() === code.toUpperCase());
    
    if (promoCode) {
      promoCode.usageCount++;
      localStorage.setItem('promoCodes', JSON.stringify(promoCodes));
    }
  }
};